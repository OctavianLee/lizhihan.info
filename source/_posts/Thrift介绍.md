title: Thrift介绍
date: 2015-07-13 16:43:42
tags: [Thrift,系统服务]
categories: 系统服务
---

本文结合Fackbook推出的文章进行翻译总结，介绍了Thrift的一些内容。

# Thrift

Thrift是由Facebook开发的服务框架方案，它加速了高效和可扩展后端服务的开发和实现。使跨编程语言的高效、可靠通信成为可能。

本篇笔记主要记录了Thrift的一些技术细节并进行说明。

## 开发背景

当网络服务日益增多，需要不同的程序语言进行服务，为了让不同语言之间能够有效的进行通信，Facebook开发出了Thrift方案来满足整体的服务需求。

该方案包括：

+ 跨语言的中立软件软件堆栈；
+ 代码生成引擎来将简单接口和数据定义语义转化成客户端和服务器远程过程调用库；
+ 选择静态代码产生方式创建有效代码；
+ 只需一个单独精简的文件。

## 主要标识：

Thrift使用了如下的标识：

+ 类型(Types)：不要求使用Thrift数据类型或写专属的序列化代码；
+ 传输(Transport)：每种语言有通用的接口来进行双向原始数据传输，给定传输的细节的实现与开发人员无关；
+ 协议(Protocol)：数据类型必须要有一些方法来让传输层进行编码；
+ 版本控制(Versioning)：对于稳健的服务，数据类型必须提供一种机制进行版本控制。可以在不中断服务的前提下，添加或删除对象中的字段，或者改变函数的参数列表；
+ 处理器(Processors)：生产能够处理数据流并完成远程过程调用的代码。

下面对这些主要的标识进行说明介绍。


# 类型

Thrift类型系统的目的是不论使用哪种编程语言，使程序员能完全使用原生定义的类型。不引入任何特殊的动态类型或者包装对象。不要求开放人员为对象序列化或传输任何代码。

Thrift的接口定义语言(Interface Definition Language)文件，以最小的额外对象使开发者注解他们的数据结构，来告诉代码产生器如何安全的跨语言传输对象。

## 基本类型

Thrift系统类型只依赖少量的基本类型，且关注所有程序语言中都可用的关键类型，忽略只有特定语言才可用的数据类型。

Thrift支持的基本数据类型有：

+ bool：表示布尔值，true或者false；
+ byte：表示有符号的字节；
+ i16：表示有符号16位整型；
+ i32：表示有符号32位整型；
+ i64：表示有符号64位整型；
+ double：表示64位浮点型；
+ string：表示一个编码未知的文本或者二进制串。

注意：

无符号整型类型，由于：

+ 无法直接映射到许多语言的原始类型；
+ 无法阻止开发者的不可知的行为。

站在设计的角度，除了算术计算目的，无符号整型几乎很少使用。
而实际项目中更多是用作一个键值或标识符，但有符号整型也有同样的作用并能在必要时候，安全地强制转化到无符号对应上去。


## 结构体

Thrift定义了通用对象来进行跨语言，等价于面向对象语言中的类，它是一个强类型的集合且每个字段都有一个唯一的标识。

定义thrift结构体的基本语法与C语言结构体的定义类似。标识一个字段，或者用一个整型字段标识符或者使用默认值，但如果该字段标识符省略的话可以自动被赋值。


## 容器

Thrift的容器时强类型的，可以映射到绝多数常用语言的容器中。


它只用C++模版或者JAVA范性进行标注。有三种可用的类型:

+ list<type>：一个有序的元素列表。直接翻译为一个STL vetor、JAVA ArrayList或者脚本语言中的原生数组，可以包含重复；
+ set<type>：一个无序且不重复的元素集。翻译成STL set、JAVA HashSet、Python set或者 PHP/Ruby中的原生字典；
+ map<type1, type2>：一个主键唯一的键值映射。翻译成STL map、JAVA HashMap、PHP的关联数组或者 python/ruby的字典。

注意：

虽然提供默认容器，但是类型映射不是显式固定的，已添加自定义代码产生器指令集会替换成目标语言中的自定义类型中。因此唯一的要求是自定义类型支持所有必需的迭代器原语，容器元素可以是任意合法的thrift类型甚至包括其他容器或结构体。

在目标语言中，每种定义产生一个类型和两种方法(read和write)，用来实现序列化和使用Thrift TProtocol对象来传输。

## 异常

异常在语法和功能上等价于结构体，使用exception关键词。

为了在任何给定语言里集成本地异常处理，生成对象继承一个异常基础类，可以无缝地与任何给定语言的原生异常整合。同样，设计上强调让应用开发者熟悉代码。

## 服务

服务使用Thrift类型进行定义使用。服务定义在语义上等价于定义个面向对象语言中的接口(或纯虚抽象类)。Thrift编译器通过接口生成完整的客户端和服务端。

服务结构定义如下：

``` thrift
service <name> {
  <returntype> <name>(<arguments>)
    [throws (<exceptions>)]
  ...
}
```

# 传输

传输层被生成的代码来进行处理数据的传输。

## 接口

Thrift实现的一个重要的设计选择是：将传输层从代码生成层中解耦。

尽管Thrift典型地使用一个流套接字在TCP/IP协议栈的顶部，并作为基础的通信层。使用抽象I/O层所带来的性能损失与实际使用的I/O操作代价相比是微不足道的。

从根本上来说，生成的Thrift代码只需要知道如何读写数据，与数据的源和目的无关。它可能是一个套接字，一段共享内存或者本地磁盘上的文件。

Thrift支持的方法如下：

+ open 开启传输;
+ close 关闭传输;
+ isOpen 看传输是否开启;
+ read 从传输中读取;
+ write 从传输中写入;
+ flush 强制挂起所有写入。

还有其他的方法没有列出，那些方法会来帮助进行批量的读取或者选择性地从生成的代码中发送一次读写的信号。

除了上述的TTransport接口外，还有TServerTransport接口来接受或者创建基本的传输对象，接口如下：

+ open 开启传输；
+ listen 开始侦听连接；
+ accept 返回一个新客户端的传输对象；
+ close 关闭传输。

## 实现

传输接口为了在任何程序语言中简单实现而设计。新的传输机制可以被容易的定义。

### TSocket

TSocket类跨所有目标语言被实现。它为TCP/IP流套接字提供了一个通用的、简单的接口。

### TFileTransport
TFileTransport是一个磁盘文件数据流的抽象。可以被用收到Thrift请求的集合写到磁盘文件中。

磁盘上的数据可以从日志中重放，也会用来进行后继处理或者模拟过去的事件。

### 设施工具
传输接口为了支持通用的OOP技术的方便扩展而被设计。

一些简单的工具包括：

+ TBufferdTransport：缓冲潜在的读和写的传输； 
+ TFramedTransport：用有大小信息的帧头部来分块优化或者进行非阻塞操作；
+ TMemoryBuffer：允许从进程里的内存堆栈进行直接读写。 

# 协议

Thrift把数据结构从传输表达中分离出来。


## 接口

Thrift协议接口有两条原则：1.双向顺序消息。2.基本类型、容器和结构的编码。

Thrift的接口如下：

+ writeMessageBegin(name, type, seq) 
+ writeMessageEnd() 
+ writeStructBegin(name) 
+ writeStructEnd() 
+ writeFieldBegin(name, type, id) 
+ writeFieldEnd()
+ writeFieldStop() 
+ writeMapBegin(ktype, vtype, size) 
+ writeMapEnd() 
+ writeListBegin(etype, size) 
+ writeListEnd() 
+ writeSetBegin(etype, size) 
+ writeSetEnd()
+ writeBool(bool)
+ writeByte(byte)
+ writeI16(i16)
+ writeI32(i32)
+ writeI64(i64)
+ writeDouble(double) 
+ writeString(string)

+ name, type, seq = readMessageBegin()      readMessageEnd()
+ name = readStructBegin() readStructEnd()
+ name, type, id = readFieldBegin()readFieldEnd()
+ k, v, size = readMapBegin() readMapEnd()
+ etype, size = readListBeign() readListEnd()
+ etype, size = readSetBegin() readSetEnd()
+ bool = readBool()
+ byte = readByte()
+ i16 = readI16()
+ i32 = readI32()
+ i64 = readI64()
+ double = readDouble()
+ string = readString()

注意： 除了writeFieldStop()外，每个write函数都有一个read函数对应。writeFieldStop()用来发送结构结束的信号。

## 结构

Thrift结构被设计来支持编码进一个流协议。协议实现在编码前不需要编帧或者计算整个结构的数据长度。

结构不会先编码数据长度。他们作为字段序列被编码，每个字段有一个类型标识符和一个唯一的字段标识符。包括类型标识符，允许协议能够在不生成任何代码或者访问原始IDL文件的情况下，被安全地解析和解码。结构通过字段头部使用的STOP类型来判断结束。

因为所有的基本类型可以被确定性地读取，每个结构体也可以被确定性读取，Thrift协议是自我定界而不需要任何装帧和考虑编码格式。在不需要流或者装帧的情况下，可以使用TFrameTransport来将其简单地添加到传输层上。

# 版本管理

Thrift在版本控制和数据定义改变方面是稳健的。系统必须能够支持从日志文件中读取旧数据，从过期客户端请求到新的服务器。

## 字段标识符

在Thrift中版本控制通过字段标识符来实现。结构体中的每个成员的字段头部都用一个唯一的字段标识符来编码。这个字段标识符和它的类型标识符的组合能够唯一地确认字段。Thrift的定义语言支持自动分配字段标识符，好的程序实践是：显式地说明字段标识符。
 
为了避免人工和自动分配标识符冲突，忽略了标识符的字段会自动从-1递减分配字段标识符。

当数据反序列化时，生成的代码可以使用这些标识符来正确地确认字段并判断是否与它的定义文件里的字段匹配。如果一个字符标识符不被识别，生成的代码会使用类型标识符来无错地跳过这个未知的字段。这是由于 所有的数据类型是自我定界的。

字符标识符可以且应该在函数参数列表中说明。变量列表在后端中不单作为结构体，事实上还在编译前端共享同样的代码，这允许版本安全地修改函数的参数。



## isset

当遇到一个不期望的字段，可以被安全地无视和丢弃。当没有发现一个期望的字段，必须有一些方法来通知开发者没有出现。这是通过在定义的数据对象中内部的isset结构体来实现，位于已定义对象的内部。

本质上，每个Thrift结构体内部的isset对象为每一个字段包含一个布尔值，来指明该字段是不是在结构体中。

## 案例分析

版本不匹配会在以下四个案例中经常遇到：

+ 增加了字段，旧的客户端，新的服务器。旧的客户端不发送新的字段，新的服务器认识到字段没有被设置， 默认进行旧的请求。
+ 移除了字段，旧的客户端，新的服务器。旧的客户端发送移除的字段，新的服务器只是简单的忽视它。
+ 增加了字段，新的客户端，旧的服务器。新的客户端发送一个旧服务器不能识别的字段，旧的服务器只是忽视它并正常处理。
+ 移除了字段，新的客户端，旧的服务器。这个案例会比较危险，因为旧服务器不像有合适的默认行为，实现没有的字段。建议这种情况下，新的服务器架设优先于新客户端。




***

版本修改记录：

+ 2015-07-13 完成本篇文章全部内容。 By Octavian
